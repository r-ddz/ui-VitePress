## MySQL的索引为什么用B+树？ 

- B+树更矮胖，IO效率高：B+树的非叶子节点不存数据，只存索引，因此B+树更矮胖，3-4层就能存储海量数据，减少磁盘IO次数。

- 查询稳定：所有数据都在叶子节点，查询路径长度相同。

- 范围查询优：叶子节点形成有序链表，范围查询非常高效。


## 什么是聚簇索引和非聚簇索引？

- 聚簇索引：数据与索引存储在一起，一个表只能有一个，通常是主键。查询时直接获取数据，性能最好。

- 非聚簇索引：索引与数据分开存储，叶子节点存储主键值，需要回表查询。一个表可以有多个。


## 事务的隔离级别有哪些？ MySQL默认级别是什么？分别解决了哪些问题？

- READ UNCOMMITTED（读取未提交）： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
- READ COMMITTED（读取已提交）： 允许读取并发事务已经提交的数据，可以阻止重读，但是幻读或不可重复读仍有可能发生。
- REPEATABLE READ（可重复读）： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止重读和不可重复读，但幻读仍有可能发生。
- SERIALIZABLE（可串行化）： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止空读、不可重复读以及幻读。

> MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE READ（可重复读）。


## 如何定位并优化一条慢SQL？ 

- 开启慢查询日志，比如执行超过1秒的SQL。当然我们使用的是阿里的高可用RDS，直接后台定期导出慢查询日志分析。

- 监控查看当前执行的SQL，`SHOW PROCESSLIST;`，或者Navicat的监控工具，找出慢SQL。

- 使用EXPLAIN命令分析SQL的执行计划，查看是否使用了索引，以及索引的使用情况。


## SQL优化 EXPLAIN 命令你关注哪些字段？

- type：访问类型，要避免ALL全表扫描，争取达到ref或range

- key：实际使用的索引，确保使用了合适的索引

- rows：预估扫描行数，行数越少越好

- possible_keys：可能使用的索引，帮助判断索引设计是否合理


## Redis有哪些数据类型？分别在什么场景下使用？

- 字符串（String）：例如JSON字符串缓存，例如锁。
- 列表（List）：例如消息。
- 哈希（Hash）：相比将整个对象JSON序列化成字符串，哈希对字段分开存储更高效。
- 集合（Set）：去重效果，交集/并集，例如共同好友功能
- 有序集合（Sorted Set）：排序，例如排行榜


## 缓存穿透、缓存击穿、缓存雪崩是什么？如何解决？

- 缓存穿透：查询不存在的数据。（方案1：缓存空对象；方案2：布隆过滤器）

- 缓存击穿：热点数据过期的瞬间，大量数据请求到数据库。（方案1：加锁查库；方案2：热点不过期）

- 缓存雪崩：大量缓存key在同一时间失效。（方案1：随机过期时间；方案2：热点不过期）
