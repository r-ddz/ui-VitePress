## Spring中Bean的生命周期是怎样的？

1. 通过构造函数实例化Bean
2. 进行依赖注入（属性赋值）
3. 执行各种Aware接口的回调（BeanNameAware、BeanFactoryAware等）
4. BeanPostProcessor的初始化前处理
5. 执行初始化方法（@PostConstruct、InitializingBean、自定义init-method）
6. BeanPostProcessor的初始化后处理
7. Bean准备就绪，可以被使用
8. 容器关闭时执行销毁方法（@PreDestroy、DisposableBean、自定义destroy-method）

> 在实际项目中，我们常用初始化方法进行资源初始化，用销毁方法进行资源清理，通过初始化前后处理实现AOP等扩展功能。


## Spring事务的传播机制有哪些？ 你在项目中用过哪些？

- PROPAGATION_REQUIRED（默认）：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- PROPAGATION_SUPPORTS：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- PROPAGATION_MANDATORY：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
- PROPAGATION_REQUIRES_NEW：创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- PROPAGATION_NOT_SUPPORTED：以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- PROPAGATION_NEVER：以非事务方式运行，如果当前存在事务，则抛出异常。
- PROPAGATION_NESTED：如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于PROPAGATION_REQUIRED。


## 你们微服务架构用了哪些组件？ 说说 Nacos、OpenFeign、Sentinel 各自的作用。

- 网关层: Spring Cloud Gateway
- 注册中心: Nacos
- 配置中心: Nacos  
- 服务调用: OpenFeign
- 熔断降级: Sentinel


## 消息队列如何保证消息不丢失？ 

- 生产者确认机制（ACK），确保消息成功送达Broker
- 配置持久化，确保消息写入磁盘
- 消费者使用手动确认机制，确保业务处理成功后才确认消息


## 如何保证消息不被重复消费？（幂等性）

> redis分布式锁 + 业务数据状态检测


## 你在项目中使用Docker做了什么？ 

- 快速部署：使用Docker Compose在开发环境快速搭建整套微服务依赖

- CI/CD集成：在流水线中构建Docker镜像，实现应用的标准交付

## 了解Kubernetes吗？

> yaml配置跟Docker Compose很类似，但内部实现了负载均衡，还可以弹性扩容

